# Compare_C_Rust_With_Benchmark

### Envirement
MacBook M3 Pro 36GB

Mac Os 15.4.1

C : gcc compiler 

```zsh
gcc -O2 Benchmark_C.c -o Benchmark_C
```

Rust : rustc compiler 

```zsh
rustc -O Benchmark_Rust.rs
```

---
### 코드 설명

두 코드는 모두 "The_Adventures_of_Sherlock_Holmes.txt" 파일에서 "the"라는 단어가 몇 번 등장하는지 세고, 실행 시간을 측정하는 동일한 작업을 수행합니다. 하지만 구현 방식에서 차이를 보이며, 이는 제공해주신 "함수형 언어의 특성" 슬라이드의 내용과 관련이 깊습니다.

**1. C 코드 (search_with_loop 함수 중심)**

* **접근 방식:** 명령형 프로그래밍 스타일을 따릅니다. 개발자가 파일 읽기, 문자열 처리, 검색, 개수 세기 등 모든 단계를 명시적인 루프(`while`)와 조건문, 포인터 조작(`strstr`, `ptr += 1`)을 통해 직접 제어합니다. 
* **파일 읽기:** `fopen`으로 파일을 열고 `getline` 함수 (POSIX 표준)를 사용하여 한 줄씩 읽습니다. `getline`은 필요한 메모리를 동적으로 할당합니다.
* **문자열 처리:**
    * 읽어온 줄의 끝에 있는 개행 문자를 제거합니다.
    * 대소문자를 구분하지 않기 위해, `strdup`으로 원본 문자열을 복사한 후 `to_lowercase` 함수를 호출하여 복사본을 소문자로 변환합니다. 원본 문자열을 변경하지 않기 위해 복사본을 사용합니다.
    * `to_lowercase` 함수는 문자열의 각 문자를 순회하며 `tolower` 함수를 적용합니다.
* **검색:** `strstr` 함수를 사용하여 현재 줄(소문자로 변환된 복사본)에서 "the" 문자열을 찾습니다. `while` 루프를 통해 해당 줄에서 "the"가 더 이상 없을 때까지 반복적으로 검색합니다.
    * `ptr += 1` 부분은 "theatre" 같은 단어에서도 "the"를 찾거나, "thethe"와 같이 겹치는 경우도 세기 위함입니다 (주석에 설명된 대로).
* **메모리 관리:** `strdup`으로 할당된 메모리(`lower_line`)와 `getline`이 할당한 메모리(`line`)를 `free` 함수를 통해 직접 해제해야 합니다.
* **시간 측정:** `clock()` 함수를 사용하여 CPU 사용 시간을 측정합니다.
* **슬라이드와의 관계:** 슬라이드 5에서 언급된 "C Loop Version"에 해당합니다. 명시적인 루프와 저수준 문자열/메모리 조작을 사용하는 전통적인 C 스타일의 구현입니다. 

**2. Rust 코드 (search_with_iterator 함수 중심)**

* **접근 방식:** 함수형 프로그래밍의 영향을 받은 선언적 스타일, 특히 이터레이터(Iterator)를 적극 활용합니다. 
* **파일 읽기:** `File::open`으로 파일을 열고 `BufReader`를 사용하여 버퍼링된 읽기를 수행합니다. `?` 연산자를 통해 파일 열기 실패 시 에러를 간결하게 처리합니다.
* **파일 처리:** `reader.lines()` 메서드는 파일의 각 줄을 생성하는 *이터레이터*를 반환합니다. `for` 루프는 이 이터레이터를 순회합니다.
* **문자열 처리:**
    * `line_result?`를 통해 각 줄 읽기의 성공 여부를 확인하고 성공 시 문자열(`line`)을 얻습니다.
    * `line.to_lowercase()` 메서드를 호출하여 각 줄을 소문자로 변환합니다. 이 메서드는 새로운 소문자 문자열(`String`)을 반환합니다. (C 코드처럼 원본을 수정하지 않고 새 값을 만듭니다).
* **검색:**
    * `lower_line.matches(search_term)` 메서드는 소문자 문자열 내에서 "the" 문자열과 일치하는 모든 부분 문자열을 찾아내는 *이터레이터*를 반환합니다. 
    * `.count()` 메서드는 이 *이터레이터*가 생성하는 요소의 개수, 즉 해당 줄에서 "the"가 등장한 횟수를 계산합니다. 
    * 이 값을 `count` 변수에 더합니다.
* **메모리 관리:** Rust의 소유권(Ownership) 시스템 덕분에 개발자가 직접 메모리를 할당하거나 해제할 필요가 없습니다. `String` 등의 객체는 스코프를 벗어나면 자동으로 메모리가 해제됩니다.
* **시간 측정:** `std::time::Instant`를 사용하여 경과 시간을 측정합니다.
* **슬라이드와의 관계:**
    * 슬라이드 4에서 설명된 이터레이터(Iterator) 개념을 핵심적으로 사용합니다 (`lines()`, `matches()`, `count()`). 
    * 슬라이드 5에서 언급된 "Rust Iterator Version"에 해당합니다. 고수준의 이터레이터 메서드를 연쇄적으로 호출하여 작업을 선언적으로 표현하며, 이는 함수형 프로그래밍 스타일의 특징 중 하나입니다.

**요약:**

두 코드는 같은 문제를 해결하지만, C 코드는 명시적인 루프와 수동 메모리 관리를 사용하는 명령형 방식을, Rust 코드는 고수준의 이터레이터와 자동 메모리 관리를 활용하는 더 선언적이고 함수형 스타일에 가까운 방식을 사용합니다. 슬라이드에서 설명하는 것처럼 Rust의 이터레이터 방식은 C의 루프 방식과 유사한 성능을 내면서도 코드를 더 간결하고 안전하게 작성할 수 있게 해줍니다.

<img width="884" alt="image" src="https://github.com/user-attachments/assets/f0744a82-6140-4dce-899e-3763a177a952" />
